"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/AppContext.tsx":
/*!*************************************!*\
  !*** ./src/contexts/AppContext.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AppProvider: function() { return /* binding */ AppProvider; },\n/* harmony export */   useApp: function() { return /* binding */ useApp; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"./node_modules/socket.io-client/build/esm/index.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst AppContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst AppProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // user state (start null on server to avoid hydration mismatch)\n    const [user, _setUser] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [blockedUsers, setBlockedUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    // ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹\n    const refreshBlockedUsers = async ()=>{\n        if (!user) return;\n        try {\n            const response = await fetch(\"http://localhost:5001/api/users/blocked?userId=\".concat(user.id));\n            if (!response.ok) throw new Error(\"Failed to fetch blocked users\");\n            const data = await response.json();\n            setBlockedUsers(new Set(data.blockedUsers));\n        } catch (err) {\n            console.error(\"Failed to refresh blocked users:\", err);\n        }\n    };\n    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²ÐºÐ¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ\n    const checkBlockStatus = async (userId)=>{\n        if (!user) return false;\n        try {\n            const response = await fetch(\"http://localhost:5001/api/users/block-status/\".concat(userId, \"?checkedById=\").concat(user.id));\n            if (!response.ok) throw new Error(\"Failed to check block status\");\n            const data = await response.json();\n            return data.isBlocked;\n        } catch (err) {\n            console.error(\"Block status check error:\", err);\n            return false;\n        }\n    };\n    // wrapper to keep localStorage in sync\n    const setUser = (u)=>{\n        try {\n            if (true) {\n                if (u) localStorage.setItem(\"krx_user\", JSON.stringify(u));\n                else localStorage.removeItem(\"krx_user\");\n            }\n        } catch (e) {\n            console.warn(\"Failed to persist user to localStorage\", e);\n        }\n        _setUser(u);\n    };\n    // On client mount read persisted user to restore session (avoids server/client markup mismatch)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (false) {}\n        try {\n            const raw = localStorage.getItem(\"krx_user\");\n            if (raw) {\n                const parsed = JSON.parse(raw);\n                _setUser(parsed);\n            }\n        } catch (e) {\n        // ignore parse errors\n        }\n    }, []);\n    // Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹ Ð¿Ñ€Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐµ Ð¸ ÑÐ¼ÐµÐ½Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (user) {\n            refreshBlockedUsers();\n        }\n    }, [\n        user\n    ]);\n    const [socket, setSocket] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [darkMode, setDarkMode] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        return localStorage.getItem(\"theme\") === \"dark\";\n    });\n    const [chats, setChats] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentChat, setCurrentChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({}); // chatId -> array of userIds\n    const [notifyEnabled, setNotifyEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        try {\n            if (true) {\n                const raw = localStorage.getItem(\"krx_notify_enabled\");\n                return raw ? JSON.parse(raw) : false;\n            }\n        } catch (e) {}\n        return false;\n    });\n    const [soundEnabled, setSoundEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(()=>{\n        try {\n            if (true) {\n                const raw = localStorage.getItem(\"krx_sound_enabled\");\n                return raw ? JSON.parse(raw) : true;\n            }\n        } catch (e) {}\n        return true;\n    });\n    // On-client muted chats stored in localStorage (client preference)\n    // We persist per-chat muted state in localStorage under 'krx_muted_chats'\n    // Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ\n    const sendMessage = (content, chatId, messageType, isComment)=>{\n        if (!socket || !user) return;\n        const messageData = {\n            chatId,\n            senderId: user.id,\n            content: content.trim(),\n            isComment: isComment || false\n        };\n        if (messageType) messageData.messageType = messageType;\n        console.log(\"\\uD83D\\uDCE4 Sending message:\", messageData);\n        socket.emit(\"send_message\", messageData);\n        // ÐžÐŸÐ¢Ð˜ÐœÐ˜Ð¡Ð¢Ð˜Ð§Ð•Ð¡ÐšÐžÐ• ÐžÐ‘ÐÐžÐ’Ð›Ð•ÐÐ˜Ð• - ÑÑ€Ð°Ð·Ñƒ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ\n        const optimisticMessage = {\n            id: Date.now(),\n            chatId,\n            senderId: user.id,\n            content: content.trim(),\n            messageType: messageData.messageType || \"text\",\n            isRead: false,\n            timestamp: new Date().toISOString(),\n            username: user.username,\n            displayName: user.displayName,\n            avatarUrl: user.avatarUrl\n        };\n        setMessages((prev)=>[\n                ...prev,\n                optimisticMessage\n            ]);\n    };\n    // Normalize server message shape to client Message interface (camelCase)\n    const normalizeMessage = (m)=>{\n        var _m_chat_id, _m_sender_id, _m_message_type, _ref, _m_timestamp, _ref1, _m_username, _ref2, _m_displayName, _ref3, _m_reactions;\n        return {\n            id: Number(m.id),\n            chatId: Number((_m_chat_id = m.chat_id) !== null && _m_chat_id !== void 0 ? _m_chat_id : m.chatId),\n            senderId: Number((_m_sender_id = m.sender_id) !== null && _m_sender_id !== void 0 ? _m_sender_id : m.senderId),\n            // ensure media urls are absolute so audio/img/video load correctly from client\n            content: (()=>{\n                var _m_content;\n                const raw = (_m_content = m.content) !== null && _m_content !== void 0 ? _m_content : \"\";\n                if (typeof raw === \"string\" && raw.startsWith(\"/\")) return \"http://localhost:5001\".concat(raw);\n                return raw;\n            })(),\n            messageType: (_ref = (_m_message_type = m.message_type) !== null && _m_message_type !== void 0 ? _m_message_type : m.messageType) !== null && _ref !== void 0 ? _ref : \"text\",\n            isRead: m.is_read === 1 || m.isRead || false,\n            timestamp: (_ref1 = (_m_timestamp = m.timestamp) !== null && _m_timestamp !== void 0 ? _m_timestamp : m.created_at) !== null && _ref1 !== void 0 ? _ref1 : new Date().toISOString(),\n            username: (_ref2 = (_m_username = m.username) !== null && _m_username !== void 0 ? _m_username : m.userName) !== null && _ref2 !== void 0 ? _ref2 : \"\",\n            displayName: (_ref3 = (_m_displayName = m.displayName) !== null && _m_displayName !== void 0 ? _m_displayName : m.display_name) !== null && _ref3 !== void 0 ? _ref3 : \"\",\n            avatarUrl: (()=>{\n                var _m_avatarUrl, _ref;\n                const a = (_ref = (_m_avatarUrl = m.avatarUrl) !== null && _m_avatarUrl !== void 0 ? _m_avatarUrl : m.avatar_url) !== null && _ref !== void 0 ? _ref : undefined;\n                if (typeof a === \"string\" && a.startsWith(\"/\")) return \"http://localhost:5001\".concat(a);\n                return a;\n            })(),\n            reactions: (_m_reactions = m.reactions) !== null && _m_reactions !== void 0 ? _m_reactions : []\n        };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (user) {\n            // Create socket with reconnection options so it survives short network glitches\n            const newSocket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"http://localhost:5001\", {\n                transports: [\n                    \"websocket\"\n                ],\n                reconnection: true,\n                reconnectionAttempts: Infinity,\n                reconnectionDelay: 1000,\n                reconnectionDelayMax: 5000,\n                autoConnect: true\n            });\n            // ÐžÑÐ½Ð¾Ð²Ð½Ñ‹Ðµ ÑÐ¾Ð±Ñ‹Ñ‚Ð¸Ñ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ\n            newSocket.emit(\"user_online\", user.id);\n            newSocket.emit(\"join_chats\", user.id);\n            newSocket.emit(\"get_chats\", user.id);\n            // ðŸ“© ÐŸÐžÐ›Ð£Ð§Ð•ÐÐ˜Ð• ÐÐžÐ’Ð«Ð¥ Ð¡ÐžÐžÐ‘Ð©Ð•ÐÐ˜Ð™ Ð’ Ð Ð•ÐÐ›Ð¬ÐÐžÐœ Ð’Ð Ð•ÐœÐ•ÐÐ˜\n            newSocket.on(\"receive_message\", (rawMsg)=>{\n                const message = normalizeMessage(rawMsg);\n                console.log(\"\\uD83D\\uDCE9 Received new message:\", message);\n                if (currentChat && message.chatId === currentChat.id) {\n                    setMessages((prev)=>{\n                        // Remove optimistic duplicate messages: match by senderId + content + close timestamp\n                        const filtered = prev.filter((m)=>{\n                            try {\n                                if (Number(m.senderId) === Number(message.senderId) && m.content === message.content) {\n                                    const tPrev = new Date(m.timestamp).getTime();\n                                    const tMsg = new Date(message.timestamp).getTime();\n                                    if (Math.abs(tPrev - tMsg) < 15000) {\n                                        // drop optimistic\n                                        return false;\n                                    }\n                                }\n                            } catch (e) {\n                            // keep if any parse error\n                            }\n                            return true;\n                        });\n                        return [\n                            ...filtered,\n                            message\n                        ];\n                    });\n                }\n                // If message for other chat, increment unread count and optionally show notification\n                if (!currentChat || message.chatId !== currentChat.id) {\n                    console.log(\"\\uD83D\\uDCA1 New message in different chat\");\n                    setChats((prev)=>prev.map((c)=>{\n                            if (Number(c.id) === Number(message.chatId)) {\n                                return {\n                                    ...c,\n                                    unreadCount: (c.unreadCount || 0) + 1,\n                                    lastMessage: message.content,\n                                    lastMessageTime: message.timestamp,\n                                    lastMessageSender: message.displayName\n                                };\n                            }\n                            return c;\n                        }));\n                    // find chat and check muted flag\n                    try {\n                        const chat = chats.find((ch)=>Number(ch.id) === Number(message.chatId));\n                        const isMuted = chat === null || chat === void 0 ? void 0 : chat.muted;\n                        // show browser notification if global notifications enabled, chat is not muted and permission granted\n                        if (notifyEnabled && \"object\" !== \"undefined\" && !isMuted && \"Notification\" in window && Notification.permission === \"granted\") {\n                            var _chat_otherUser;\n                            const title = (chat === null || chat === void 0 ? void 0 : chat.type) === \"direct\" ? ((_chat_otherUser = chat.otherUser) === null || _chat_otherUser === void 0 ? void 0 : _chat_otherUser.displayName) || \"New message\" : (chat === null || chat === void 0 ? void 0 : chat.name) || \"New message\";\n                            const body = \"\".concat(message.displayName, \": \").concat(typeof message.content === \"string\" ? message.content.slice(0, 120) : \"\");\n                            try {\n                                new Notification(title, {\n                                    body,\n                                    icon: message.avatarUrl\n                                });\n                            } catch (e) {\n                                console.warn(\"Notification error\", e);\n                            }\n                        }\n                        // play sound if enabled and chat not muted\n                        if (soundEnabled && !isMuted) {\n                            try {\n                                playNotificationSound();\n                            } catch (e) {}\n                        }\n                    } catch (e) {\n                    // ignore\n                    }\n                }\n            });\n            // ðŸ§© Ð ÐµÐ°ÐºÑ†Ð¸Ð¸ Ð½Ð° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ (Ñ€Ðµaltime)\n            newSocket.on(\"reaction_added\", (data)=>{\n                setMessages((prev)=>prev.map((m)=>{\n                        if (m.id === Number(data.messageId)) {\n                            const existing = m.reactions || [];\n                            // Add reaction with correct type\n                            return {\n                                ...m,\n                                reactions: [\n                                    ...existing,\n                                    {\n                                        id: Date.now(),\n                                        userId: data.userId,\n                                        userName: \"\",\n                                        emoji: data.emoji,\n                                        createdAt: new Date().toISOString()\n                                    }\n                                ]\n                            };\n                        }\n                        return m;\n                    }));\n            });\n            newSocket.on(\"reaction_removed\", (data)=>{\n                setMessages((prev)=>prev.map((m)=>{\n                        if (m.id === Number(data.messageId)) {\n                            const existing = m.reactions || [];\n                            return {\n                                ...m,\n                                reactions: existing.filter((r)=>!(r.userId === data.userId && r.emoji === data.emoji))\n                            };\n                        }\n                        return m;\n                    }));\n            });\n            // Ð¢Ð¸Ð¿Ð¸Ð½Ð³ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ñ‹\n            newSocket.on(\"user_typing\", (data)=>{\n                setTypingUsers((prev)=>{\n                    const arr = new Set(prev[data.chatId] || []);\n                    arr.add(data.userId);\n                    return {\n                        ...prev,\n                        [data.chatId]: Array.from(arr)\n                    };\n                });\n            });\n            newSocket.on(\"user_stop_typing\", (data)=>{\n                setTypingUsers((prev)=>{\n                    const list = (prev[data.chatId] || []).filter((id)=>id !== data.userId);\n                    return {\n                        ...prev,\n                        [data.chatId]: list\n                    };\n                });\n            });\n            // Read receipts\n            newSocket.on(\"read_receipt\", (data)=>{\n                console.log(\"\\uD83D\\uDCD7 Read receipt\", data);\n                // if server notifies this user that messages were read, clear unread for that chat\n                try {\n                    if (data.userId === user.id) {\n                        setChats((prev)=>prev.map((c)=>c.id === data.chatId ? {\n                                    ...c,\n                                    unreadCount: 0\n                                } : c));\n                    }\n                } catch (e) {}\n            });\n            // ðŸ†• ÐŸÐžÐ›Ð£Ð§Ð•ÐÐ˜Ð• ÐÐžÐ’Ð«Ð¥ Ð“Ð Ð£ÐŸÐŸ\n            newSocket.on(\"new_group\", (newGroup)=>{\n                console.log(\"\\uD83C\\uDD95 Received new group:\", newGroup);\n                setChats((prev)=>{\n                    // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½ÐµÑ‚ Ð»Ð¸ ÑƒÐ¶Ðµ Ñ‚Ð°ÐºÐ¾Ð¹ Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹\n                    const exists = prev.find((chat)=>chat.id === newGroup.id);\n                    if (!exists) {\n                        return [\n                            newGroup,\n                            ...prev\n                        ];\n                    }\n                    return prev;\n                });\n            });\n            // ðŸ†• ÐŸÐžÐ›Ð£Ð§Ð•ÐÐ˜Ð• ÐÐžÐ’Ð«Ð¥ ÐšÐÐÐÐ›ÐžÐ’\n            newSocket.on(\"new_channel\", (newChannel)=>{\n                console.log(\"\\uD83C\\uDD95 Received new channel:\", newChannel);\n                setChats((prev)=>{\n                    const exists = prev.find((chat)=>chat.id === newChannel.id);\n                    if (!exists) return [\n                        newChannel,\n                        ...prev\n                    ];\n                    return prev;\n                });\n            });\n            // ðŸ”„ ÐžÐ‘ÐÐžÐ’Ð›Ð•ÐÐ˜Ð• Ð¡ÐŸÐ˜Ð¡ÐšÐ Ð§ÐÐ¢ÐžÐ’\n            newSocket.on(\"update_chats\", ()=>{\n                console.log(\"\\uD83D\\uDD04 Updating chats list\");\n                newSocket.emit(\"get_chats\", user.id);\n            });\n            // ðŸ“‹ ÐŸÐžÐ›Ð£Ð§Ð•ÐÐ˜Ð• Ð¡ÐŸÐ˜Ð¡ÐšÐ Ð§ÐÐ¢ÐžÐ’\n            newSocket.on(\"chats_list\", (chatsData)=>{\n                console.log(\"\\uD83D\\uDCCB Received chats list:\", chatsData.length, \"chats\");\n                // apply persisted muted flags\n                try {\n                    const raw =  true ? localStorage.getItem(\"krx_muted_chats\") : 0;\n                    const mutedIds = raw ? JSON.parse(raw) : [];\n                    const mapped = chatsData.map((c)=>({\n                            ...c,\n                            muted: mutedIds.includes(c.id)\n                        }));\n                    setChats(mapped);\n                } catch (e) {\n                    setChats(chatsData);\n                }\n            });\n            // ðŸ’¬ ÐŸÐžÐ›Ð£Ð§Ð•ÐÐ˜Ð• Ð˜Ð¡Ð¢ÐžÐ Ð˜Ð˜ Ð¡ÐžÐžÐ‘Ð©Ð•ÐÐ˜Ð™\n            newSocket.on(\"messages_history\", (data)=>{\n                if (currentChat && data.chatId === currentChat.id) {\n                    console.log(\"\\uD83D\\uDCAC Received messages history:\", data.messages.length, \"messages\");\n                    const normalized = data.messages.map(normalizeMessage);\n                    setMessages(normalized);\n                }\n            });\n            setSocket(newSocket);\n            loadChats(); // Ð”ÑƒÐ±Ð»Ð¸Ñ€ÑƒÐµÐ¼ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ Ñ‡ÐµÑ€ÐµÐ· REST API\n            return ()=>{\n                newSocket.disconnect();\n            };\n        }\n    }, [\n        user,\n        currentChat\n    ]);\n    // Simple WebAudio beep for notification sound (short beep)\n    const playNotificationSound = ()=>{\n        try {\n            const AudioCtx = window.AudioContext || window.webkitAudioContext;\n            if (!AudioCtx) return;\n            const ctx = new AudioCtx();\n            const o = ctx.createOscillator();\n            const g = ctx.createGain();\n            o.type = \"sine\";\n            o.frequency.value = 880; // A5\n            g.gain.value = 0.0015; // low volume\n            o.connect(g);\n            g.connect(ctx.destination);\n            o.start();\n            setTimeout(()=>{\n                o.stop();\n                try {\n                    ctx.close();\n                } catch (e) {}\n            }, 120);\n        } catch (e) {\n        // ignore\n        }\n    };\n    const toggleNotify = (enabled)=>{\n        const next = typeof enabled === \"boolean\" ? enabled : !notifyEnabled;\n        setNotifyEnabled(next);\n        try {\n            if (true) localStorage.setItem(\"krx_notify_enabled\", JSON.stringify(next));\n        } catch (e) {}\n        if (next && \"object\" !== \"undefined\" && \"Notification\" in window && Notification.permission === \"default\") {\n            try {\n                Notification.requestPermission();\n            } catch (e) {}\n        }\n    };\n    const toggleSound = (enabled)=>{\n        const next = typeof enabled === \"boolean\" ? enabled : !soundEnabled;\n        setSoundEnabled(next);\n        try {\n            if (true) localStorage.setItem(\"krx_sound_enabled\", JSON.stringify(next));\n        } catch (e) {}\n    };\n    const toggleDarkMode = ()=>{\n        setDarkMode((prev)=>{\n            const newMode = !prev;\n            localStorage.setItem(\"theme\", newMode ? \"dark\" : \"light\");\n            return newMode;\n        });\n    };\n    // Ask for Notification permission once on client (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if ( true && \"Notification\" in window) {\n            if (Notification.permission === \"default\") {\n                try {\n                    Notification.requestPermission();\n                } catch (e) {}\n            }\n        }\n    }, []);\n    // Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ñ‡Ð°Ñ‚Ð¾Ð² Ñ‡ÐµÑ€ÐµÐ· REST API\n    const loadChats = async ()=>{\n        if (!user) return;\n        try {\n            const response = await fetch(\"http://localhost:5001/api/chats?userId=\".concat(user.id));\n            if (response.ok) {\n                const chatsData = await response.json();\n                setChats(chatsData);\n                console.log(\"âœ… Loaded chats via REST:\", chatsData.length);\n            }\n        } catch (error) {\n            console.error(\"âŒ Error loading chats:\", error);\n        }\n    };\n    // Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹\n    const loadMessages = async (chatId)=>{\n        if (!user) return;\n        try {\n            const response = await fetch(\"http://localhost:5001/api/messages?chatId=\".concat(chatId, \"&userId=\").concat(user.id));\n            if (response.ok) {\n                const messagesData = await response.json();\n                // For each message fetch reactions (small optimization: parallel requests)\n                const messagesWithReactions = await Promise.all(messagesData.map(async (m)=>{\n                    // normalize server shape first\n                    const normalized = normalizeMessage(m);\n                    try {\n                        const r = await fetch(\"http://localhost:5001/api/messages/\".concat(m.id, \"/reactions\"));\n                        if (r.ok) {\n                            const reactions = await r.json();\n                            return {\n                                ...normalized,\n                                reactions\n                            };\n                        }\n                    } catch (err) {\n                    // ignore\n                    }\n                    return {\n                        ...normalized,\n                        reactions: []\n                    };\n                }));\n                setMessages(messagesWithReactions);\n                console.log(\"âœ… Loaded messages:\", messagesData.length);\n                // Ð¢Ð°ÐºÐ¶Ðµ Ð·Ð°Ð¿Ñ€Ð°ÑˆÐ¸Ð²Ð°ÐµÐ¼ Ñ‡ÐµÑ€ÐµÐ· socket Ð´Ð»Ñ real-time\n                if (socket) {\n                    socket.emit(\"get_messages\", {\n                        chatId,\n                        userId: user.id\n                    });\n                }\n            }\n        } catch (error) {\n            console.error(\"âŒ Error loading messages:\", error);\n        }\n    };\n    const toggleMute = (chatId)=>{\n        setChats((prev)=>{\n            const updated = prev.map((c)=>c.id === chatId ? {\n                    ...c,\n                    muted: !c.muted\n                } : c);\n            try {\n                const mutedIds = updated.filter((c)=>c.muted).map((c)=>c.id);\n                if (true) localStorage.setItem(\"krx_muted_chats\", JSON.stringify(mutedIds));\n            } catch (e) {\n            // ignore\n            }\n            return updated;\n        });\n    };\n    // Apply theme on initialization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        document.body.classList.toggle(\"dark\", darkMode);\n    }, [\n        darkMode\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(AppContext.Provider, {\n        value: {\n            user,\n            setUser,\n            socket,\n            darkMode,\n            toggleDarkMode,\n            chats,\n            setChats,\n            currentChat,\n            setCurrentChat,\n            messages,\n            setMessages,\n            toggleMute,\n            notifyEnabled,\n            toggleNotify,\n            soundEnabled,\n            toggleSound,\n            typingUsers,\n            loadChats,\n            loadMessages,\n            sendMessage,\n            checkBlockStatus,\n            blockedUsers,\n            refreshBlockedUsers\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/user/Desktop/KRX/KRX 2.0/client/src/contexts/AppContext.tsx\",\n        lineNumber: 514,\n        columnNumber: 5\n    }, undefined);\n};\n_s(AppProvider, \"IMGjYdH4OIHiMTb6xuWwBce51Cs=\");\n_c = AppProvider;\nconst useApp = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(AppContext);\n    if (context === undefined) {\n        throw new Error(\"useApp must be used within an AppProvider\");\n    }\n    return context;\n};\n_s1(useApp, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WUFDQWhJO1lBQ0FvSDtZQUNBbEg7WUFDQXNIO1lBQ0ExSDtZQUNBbUc7WUFDQTBCO1lBQ0F2SDtZQUNBaEM7WUFDQWQ7WUFDQUc7UUFDRjtrQkFDR047Ozs7OztBQUdQLEVBQUU7R0E3ZldEO0tBQUFBO0FBK2ZOLE1BQU1vTCxTQUFTOztJQUNwQixNQUFNQyxVQUFVM0wsaURBQVVBLENBQUNJO0lBQzNCLElBQUl1TCxZQUFZdEwsV0FBVztRQUN6QixNQUFNLElBQUlhLE1BQU07SUFDbEI7SUFDQSxPQUFPeUs7QUFDVCxFQUFFO0lBTldEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9BcHBDb250ZXh0LnRzeD9iMWQ5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgVXNlciwgQ2hhdCwgTWVzc2FnZSwgRW1vamlUeXBlIH0gZnJvbSAnLi4vdHlwZXMvdHlwZXMnO1xuaW1wb3J0IGlvLCB7IFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuXG5pbnRlcmZhY2UgQXBwQ29udGV4dFR5cGUge1xuICB1c2VyOiBVc2VyIHwgbnVsbDtcbiAgc2V0VXNlcjogKHVzZXI6IFVzZXIgfCBudWxsKSA9PiB2b2lkO1xuICBzb2NrZXQ6IFNvY2tldCB8IG51bGw7XG4gIGRhcmtNb2RlOiBib29sZWFuO1xuICB0b2dnbGVEYXJrTW9kZTogKCkgPT4gdm9pZDtcbiAgY2hhdHM6IENoYXRbXTtcbiAgc2V0Q2hhdHM6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPENoYXRbXT4+O1xuICBjdXJyZW50Q2hhdDogQ2hhdCB8IG51bGw7XG4gIHNldEN1cnJlbnRDaGF0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxDaGF0IHwgbnVsbD4+O1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuICBzZXRNZXNzYWdlczogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248TWVzc2FnZVtdPj47XG4gIGxvYWRDaGF0czogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbG9hZE1lc3NhZ2VzOiAoY2hhdElkOiBudW1iZXIpID0+IFByb21pc2U8dm9pZD47XG4gIHNlbmRNZXNzYWdlOiAoY29udGVudDogc3RyaW5nLCBjaGF0SWQ6IG51bWJlciwgbWVzc2FnZVR5cGU/OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHRvZ2dsZU11dGU6IChjaGF0SWQ6IG51bWJlcikgPT4gdm9pZDtcbiAgbm90aWZ5RW5hYmxlZDogYm9vbGVhbjtcbiAgdG9nZ2xlTm90aWZ5OiAoZW5hYmxlZD86IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNvdW5kRW5hYmxlZDogYm9vbGVhbjtcbiAgdG9nZ2xlU291bmQ6IChlbmFibGVkPzogYm9vbGVhbikgPT4gdm9pZDtcbiAgdHlwaW5nVXNlcnM6IFJlY29yZDxudW1iZXIsIG51bWJlcltdPjtcbiAgY2hlY2tCbG9ja1N0YXR1czogKHVzZXJJZDogbnVtYmVyKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICBibG9ja2VkVXNlcnM6IFNldDxudW1iZXI+O1xuICByZWZyZXNoQmxvY2tlZFVzZXJzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xufVxuXG5jb25zdCBBcHBDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxBcHBDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGNvbnN0IEFwcFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIC8vIHVzZXIgc3RhdGUgKHN0YXJ0IG51bGwgb24gc2VydmVyIHRvIGF2b2lkIGh5ZHJhdGlvbiBtaXNtYXRjaClcbiAgY29uc3QgW3VzZXIsIF9zZXRVc2VyXSA9IHVzZVN0YXRlPFVzZXIgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2Jsb2NrZWRVc2Vycywgc2V0QmxvY2tlZFVzZXJzXSA9IHVzZVN0YXRlPFNldDxudW1iZXI+PihuZXcgU2V0KCkpO1xuXG4gIC8vINCe0LHQvdC+0LLQu9C10L3QuNC1INGB0L/QuNGB0LrQsCDQt9Cw0LHQu9C+0LrQuNGA0L7QstCw0L3QvdGL0YUg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9C10LlcbiAgY29uc3QgcmVmcmVzaEJsb2NrZWRVc2VycyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo1MDAxL2FwaS91c2Vycy9ibG9ja2VkP3VzZXJJZD0ke3VzZXIuaWR9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBibG9ja2VkIHVzZXJzJyk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgc2V0QmxvY2tlZFVzZXJzKG5ldyBTZXQoZGF0YS5ibG9ja2VkVXNlcnMpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZWZyZXNoIGJsb2NrZWQgdXNlcnM6JywgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgLy8g0J/RgNC+0LLQtdGA0LrQsCDQsdC70L7QutC40YDQvtCy0LrQuCDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cbiAgY29uc3QgY2hlY2tCbG9ja1N0YXR1cyA9IGFzeW5jICh1c2VySWQ6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICBgaHR0cDovL2xvY2FsaG9zdDo1MDAxL2FwaS91c2Vycy9ibG9jay1zdGF0dXMvJHt1c2VySWR9P2NoZWNrZWRCeUlkPSR7dXNlci5pZH1gXG4gICAgICApO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY2hlY2sgYmxvY2sgc3RhdHVzJyk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgcmV0dXJuIGRhdGEuaXNCbG9ja2VkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignQmxvY2sgc3RhdHVzIGNoZWNrIGVycm9yOicsIGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIHdyYXBwZXIgdG8ga2VlcCBsb2NhbFN0b3JhZ2UgaW4gc3luY1xuICBjb25zdCBzZXRVc2VyID0gKHU6IFVzZXIgfCBudWxsKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAodSkgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2tyeF91c2VyJywgSlNPTi5zdHJpbmdpZnkodSkpO1xuICAgICAgICBlbHNlIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdrcnhfdXNlcicpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHBlcnNpc3QgdXNlciB0byBsb2NhbFN0b3JhZ2UnLCBlKTtcbiAgICB9XG4gICAgX3NldFVzZXIodSk7XG4gIH07XG5cbiAgLy8gT24gY2xpZW50IG1vdW50IHJlYWQgcGVyc2lzdGVkIHVzZXIgdG8gcmVzdG9yZSBzZXNzaW9uIChhdm9pZHMgc2VydmVyL2NsaWVudCBtYXJrdXAgbWlzbWF0Y2gpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdrcnhfdXNlcicpO1xuICAgICAgaWYgKHJhdykge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHJhdykgYXMgVXNlcjtcbiAgICAgICAgX3NldFVzZXIocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmUgcGFyc2UgZXJyb3JzXG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8g0JfQsNCz0YDRg9C20LDQtdC8INGB0L/QuNGB0L7QuiDQt9Cw0LHQu9C+0LrQuNGA0L7QstCw0L3QvdGL0YUg0L/QvtC70YzQt9C+0LLQsNGC0LXQu9C10Lkg0L/RgNC4INC30LDQs9GA0YPQt9C60LUg0Lgg0YHQvNC10L3QtSDQv9C+0LvRjNC30L7QstCw0YLQtdC70Y9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodXNlcikge1xuICAgICAgcmVmcmVzaEJsb2NrZWRVc2VycygpO1xuICAgIH1cbiAgfSwgW3VzZXJdKTtcbiAgY29uc3QgW3NvY2tldCwgc2V0U29ja2V0XSA9IHVzZVN0YXRlPFNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZGFya01vZGUsIHNldERhcmtNb2RlXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3RoZW1lJykgPT09ICdkYXJrJztcbiAgfSk7XG4gIGNvbnN0IFtjaGF0cywgc2V0Q2hhdHNdID0gdXNlU3RhdGU8Q2hhdFtdPihbXSk7XG4gIGNvbnN0IFtjdXJyZW50Q2hhdCwgc2V0Q3VycmVudENoYXRdID0gdXNlU3RhdGU8Q2hhdCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbdHlwaW5nVXNlcnMsIHNldFR5cGluZ1VzZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxudW1iZXIsIG51bWJlcltdPj4oe30pOyAvLyBjaGF0SWQgLT4gYXJyYXkgb2YgdXNlcklkc1xuICBjb25zdCBbbm90aWZ5RW5hYmxlZCwgc2V0Tm90aWZ5RW5hYmxlZF0gPSB1c2VTdGF0ZTxib29sZWFuPigoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgna3J4X25vdGlmeV9lbmFibGVkJyk7XG4gICAgICAgIHJldHVybiByYXcgPyBKU09OLnBhcnNlKHJhdykgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBjb25zdCBbc291bmRFbmFibGVkLCBzZXRTb3VuZEVuYWJsZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgcmF3ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2tyeF9zb3VuZF9lbmFibGVkJyk7XG4gICAgICAgIHJldHVybiByYXcgPyBKU09OLnBhcnNlKHJhdykgOiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgLy8gT24tY2xpZW50IG11dGVkIGNoYXRzIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2UgKGNsaWVudCBwcmVmZXJlbmNlKVxuICAvLyBXZSBwZXJzaXN0IHBlci1jaGF0IG11dGVkIHN0YXRlIGluIGxvY2FsU3RvcmFnZSB1bmRlciAna3J4X211dGVkX2NoYXRzJ1xuXG4gIC8vINCk0YPQvdC60YbQuNGPINC+0YLQv9GA0LDQstC60Lgg0YHQvtC+0LHRidC10L3QuNGPXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gKGNvbnRlbnQ6IHN0cmluZywgY2hhdElkOiBudW1iZXIsIG1lc3NhZ2VUeXBlPzogc3RyaW5nLCBpc0NvbW1lbnQ/OiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFzb2NrZXQgfHwgIXVzZXIpIHJldHVybjtcblxuICAgIGNvbnN0IG1lc3NhZ2VEYXRhOiBhbnkgPSB7XG4gICAgICBjaGF0SWQsXG4gICAgICBzZW5kZXJJZDogdXNlci5pZCxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpLFxuICAgICAgaXNDb21tZW50OiBpc0NvbW1lbnQgfHwgZmFsc2VcbiAgICB9O1xuICAgIGlmIChtZXNzYWdlVHlwZSkgbWVzc2FnZURhdGEubWVzc2FnZVR5cGUgPSBtZXNzYWdlVHlwZTtcblxuICAgIGNvbnNvbGUubG9nKCfwn5OkIFNlbmRpbmcgbWVzc2FnZTonLCBtZXNzYWdlRGF0YSk7XG4gICAgc29ja2V0LmVtaXQoJ3NlbmRfbWVzc2FnZScsIG1lc3NhZ2VEYXRhKTtcblxuICAgIC8vINCe0J/QotCY0JzQmNCh0KLQmNCn0JXQodCa0J7QlSDQntCR0J3QntCS0JvQldCd0JjQlSAtINGB0YDQsNC30YMg0L/QvtC60LDQt9GL0LLQsNC10Lwg0YHQvtC+0LHRidC10L3QuNC1XG4gICAgY29uc3Qgb3B0aW1pc3RpY01lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogRGF0ZS5ub3coKSwgLy8g0JLRgNC10LzQtdC90L3Ri9C5IElEXG4gICAgICBjaGF0SWQsXG4gICAgICBzZW5kZXJJZDogdXNlci5pZCxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudHJpbSgpLFxuICAgICAgbWVzc2FnZVR5cGU6IG1lc3NhZ2VEYXRhLm1lc3NhZ2VUeXBlIHx8ICd0ZXh0JyxcbiAgICAgIGlzUmVhZDogZmFsc2UsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVzZXJuYW1lOiB1c2VyLnVzZXJuYW1lLFxuICAgICAgZGlzcGxheU5hbWU6IHVzZXIuZGlzcGxheU5hbWUsXG4gICAgICBhdmF0YXJVcmw6IHVzZXIuYXZhdGFyVXJsXG4gICAgfTtcblxuICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIG9wdGltaXN0aWNNZXNzYWdlXSk7XG4gIH07XG5cbiAgLy8gTm9ybWFsaXplIHNlcnZlciBtZXNzYWdlIHNoYXBlIHRvIGNsaWVudCBNZXNzYWdlIGludGVyZmFjZSAoY2FtZWxDYXNlKVxuICBjb25zdCBub3JtYWxpemVNZXNzYWdlID0gKG06IGFueSk6IE1lc3NhZ2UgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogTnVtYmVyKG0uaWQpLFxuICAgICAgY2hhdElkOiBOdW1iZXIobS5jaGF0X2lkID8/IG0uY2hhdElkKSxcbiAgICAgIHNlbmRlcklkOiBOdW1iZXIobS5zZW5kZXJfaWQgPz8gbS5zZW5kZXJJZCksXG4gICAgICAvLyBlbnN1cmUgbWVkaWEgdXJscyBhcmUgYWJzb2x1dGUgc28gYXVkaW8vaW1nL3ZpZGVvIGxvYWQgY29ycmVjdGx5IGZyb20gY2xpZW50XG4gICAgICBjb250ZW50OiAoKCkgPT4ge1xuICAgICAgICBjb25zdCByYXcgPSBtLmNvbnRlbnQgPz8gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJyAmJiByYXcuc3RhcnRzV2l0aCgnLycpKSByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6NTAwMSR7cmF3fWA7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgICB9KSgpLFxuICAgICAgbWVzc2FnZVR5cGU6IG0ubWVzc2FnZV90eXBlID8/IG0ubWVzc2FnZVR5cGUgPz8gJ3RleHQnLFxuICAgICAgaXNSZWFkOiAobS5pc19yZWFkID09PSAxKSB8fCBtLmlzUmVhZCB8fCBmYWxzZSxcbiAgICAgIHRpbWVzdGFtcDogbS50aW1lc3RhbXAgPz8gbS5jcmVhdGVkX2F0ID8/IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHVzZXJuYW1lOiBtLnVzZXJuYW1lID8/IG0udXNlck5hbWUgPz8gJycsXG4gICAgICBkaXNwbGF5TmFtZTogbS5kaXNwbGF5TmFtZSA/PyBtLmRpc3BsYXlfbmFtZSA/PyAnJyxcbiAgICAgIGF2YXRhclVybDogKCgpID0+IHtcbiAgICAgICAgY29uc3QgYSA9IG0uYXZhdGFyVXJsID8/IG0uYXZhdGFyX3VybCA/PyB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycgJiYgYS5zdGFydHNXaXRoKCcvJykpIHJldHVybiBgaHR0cDovL2xvY2FsaG9zdDo1MDAxJHthfWA7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSkoKSxcbiAgICAgIHJlYWN0aW9uczogbS5yZWFjdGlvbnMgPz8gW11cbiAgICB9O1xuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBzb2NrZXQgd2l0aCByZWNvbm5lY3Rpb24gb3B0aW9ucyBzbyBpdCBzdXJ2aXZlcyBzaG9ydCBuZXR3b3JrIGdsaXRjaGVzXG4gICAgICBjb25zdCBuZXdTb2NrZXQgPSBpbygnaHR0cDovL2xvY2FsaG9zdDo1MDAxJywge1xuICAgICAgICB0cmFuc3BvcnRzOiBbJ3dlYnNvY2tldCddLFxuICAgICAgICByZWNvbm5lY3Rpb246IHRydWUsXG4gICAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiBJbmZpbml0eSxcbiAgICAgICAgcmVjb25uZWN0aW9uRGVsYXk6IDEwMDAsXG4gICAgICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4OiA1MDAwLFxuICAgICAgICBhdXRvQ29ubmVjdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vINCe0YHQvdC+0LLQvdGL0LUg0YHQvtCx0YvRgtC40Y8g0L/QvtC00LrQu9GO0YfQtdC90LjRj1xuICAgICAgbmV3U29ja2V0LmVtaXQoJ3VzZXJfb25saW5lJywgdXNlci5pZCk7XG4gICAgICBuZXdTb2NrZXQuZW1pdCgnam9pbl9jaGF0cycsIHVzZXIuaWQpO1xuICAgICAgbmV3U29ja2V0LmVtaXQoJ2dldF9jaGF0cycsIHVzZXIuaWQpO1xuICAgICAgXG4gICAgICAvLyDwn5OpINCf0J7Qm9Cj0KfQldCd0JjQlSDQndCe0JLQq9ClINCh0J7QntCR0KnQldCd0JjQmSDQkiDQoNCV0JDQm9Cs0J3QntCcINCS0KDQldCc0JXQndCYXG4gICAgICAgIG5ld1NvY2tldC5vbigncmVjZWl2ZV9tZXNzYWdlJywgKHJhd01zZzogYW55KSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5vcm1hbGl6ZU1lc3NhZ2UocmF3TXNnKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+TqSBSZWNlaXZlZCBuZXcgbWVzc2FnZTonLCBtZXNzYWdlKTtcblxuICAgICAgICAgIGlmIChjdXJyZW50Q2hhdCAmJiBtZXNzYWdlLmNoYXRJZCA9PT0gY3VycmVudENoYXQuaWQpIHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4ge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgb3B0aW1pc3RpYyBkdXBsaWNhdGUgbWVzc2FnZXM6IG1hdGNoIGJ5IHNlbmRlcklkICsgY29udGVudCArIGNsb3NlIHRpbWVzdGFtcFxuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHByZXYuZmlsdGVyKG0gPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoTnVtYmVyKG0uc2VuZGVySWQpID09PSBOdW1iZXIobWVzc2FnZS5zZW5kZXJJZCkgJiYgbS5jb250ZW50ID09PSBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdFByZXYgPSBuZXcgRGF0ZShtLnRpbWVzdGFtcCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0TXNnID0gbmV3IERhdGUobWVzc2FnZS50aW1lc3RhbXApLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRQcmV2IC0gdE1zZykgPCAxNTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3Agb3B0aW1pc3RpY1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaWYgYW55IHBhcnNlIGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFsuLi5maWx0ZXJlZCwgbWVzc2FnZV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBtZXNzYWdlIGZvciBvdGhlciBjaGF0LCBpbmNyZW1lbnQgdW5yZWFkIGNvdW50IGFuZCBvcHRpb25hbGx5IHNob3cgbm90aWZpY2F0aW9uXG4gICAgICAgICAgaWYgKCFjdXJyZW50Q2hhdCB8fCBtZXNzYWdlLmNoYXRJZCAhPT0gY3VycmVudENoYXQuaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5KhIE5ldyBtZXNzYWdlIGluIGRpZmZlcmVudCBjaGF0Jyk7XG4gICAgICAgICAgICBzZXRDaGF0cyhwcmV2ID0+IHByZXYubWFwKGMgPT4ge1xuICAgICAgICAgICAgICBpZiAoTnVtYmVyKGMuaWQpID09PSBOdW1iZXIobWVzc2FnZS5jaGF0SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgICB1bnJlYWRDb3VudDogKGMudW5yZWFkQ291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2U6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlVGltZTogbWVzc2FnZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbmRlcjogbWVzc2FnZS5kaXNwbGF5TmFtZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgY2hhdCBhbmQgY2hlY2sgbXV0ZWQgZmxhZ1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgY2hhdCA9IGNoYXRzLmZpbmQoY2ggPT4gTnVtYmVyKGNoLmlkKSA9PT0gTnVtYmVyKG1lc3NhZ2UuY2hhdElkKSk7XG4gICAgICAgICAgICAgIGNvbnN0IGlzTXV0ZWQgPSBjaGF0Py5tdXRlZDtcbiAgICAgICAgICAgICAgLy8gc2hvdyBicm93c2VyIG5vdGlmaWNhdGlvbiBpZiBnbG9iYWwgbm90aWZpY2F0aW9ucyBlbmFibGVkLCBjaGF0IGlzIG5vdCBtdXRlZCBhbmQgcGVybWlzc2lvbiBncmFudGVkXG4gICAgICAgICAgICAgIGlmIChub3RpZnlFbmFibGVkICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFpc011dGVkICYmICdOb3RpZmljYXRpb24nIGluIHdpbmRvdyAmJiBOb3RpZmljYXRpb24ucGVybWlzc2lvbiA9PT0gJ2dyYW50ZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBjaGF0Py50eXBlID09PSAnZGlyZWN0JyA/IChjaGF0Lm90aGVyVXNlcj8uZGlzcGxheU5hbWUgfHwgJ05ldyBtZXNzYWdlJykgOiAoY2hhdD8ubmFtZSB8fCAnTmV3IG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYCR7bWVzc2FnZS5kaXNwbGF5TmFtZX06ICR7dHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycgPyBtZXNzYWdlLmNvbnRlbnQuc2xpY2UoMCwgMTIwKSA6ICcnfWA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIG5ldyBOb3RpZmljYXRpb24odGl0bGUsIHsgYm9keSwgaWNvbjogbWVzc2FnZS5hdmF0YXJVcmwgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdOb3RpZmljYXRpb24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBwbGF5IHNvdW5kIGlmIGVuYWJsZWQgYW5kIGNoYXQgbm90IG11dGVkXG4gICAgICAgICAgICAgIGlmIChzb3VuZEVuYWJsZWQgJiYgIWlzTXV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkgeyBwbGF5Tm90aWZpY2F0aW9uU291bmQoKTsgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgIC8vIPCfp6kg0KDQtdCw0LrRhtC40Lgg0L3QsCDRgdC+0L7QsdGJ0LXQvdC40Y8gKNGA0LVhbHRpbWUpXG4gICAgICBuZXdTb2NrZXQub24oJ3JlYWN0aW9uX2FkZGVkJywgKGRhdGE6IHsgbWVzc2FnZUlkOiBudW1iZXIsIHVzZXJJZDogbnVtYmVyLCBlbW9qaTogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBwcmV2Lm1hcChtID0+IHtcbiAgICAgICAgICBpZiAobS5pZCA9PT0gTnVtYmVyKGRhdGEubWVzc2FnZUlkKSkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBtLnJlYWN0aW9ucyB8fCBbXTtcbiAgICAgICAgICAgIC8vIEFkZCByZWFjdGlvbiB3aXRoIGNvcnJlY3QgdHlwZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ubSxcbiAgICAgICAgICAgICAgcmVhY3Rpb25zOiBbLi4uZXhpc3RpbmcsIHsgaWQ6IERhdGUubm93KCksIHVzZXJJZDogZGF0YS51c2VySWQsIHVzZXJOYW1lOiAnJywgZW1vamk6IGRhdGEuZW1vamkgYXMgRW1vamlUeXBlLCBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICBuZXdTb2NrZXQub24oJ3JlYWN0aW9uX3JlbW92ZWQnLCAoZGF0YTogeyBtZXNzYWdlSWQ6IG51bWJlciwgdXNlcklkOiBudW1iZXIsIGVtb2ppOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYubWFwKG0gPT4ge1xuICAgICAgICAgIGlmIChtLmlkID09PSBOdW1iZXIoZGF0YS5tZXNzYWdlSWQpKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG0ucmVhY3Rpb25zIHx8IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ubSwgcmVhY3Rpb25zOiBleGlzdGluZy5maWx0ZXIociA9PiAhKHIudXNlcklkID09PSBkYXRhLnVzZXJJZCAmJiByLmVtb2ppID09PSBkYXRhLmVtb2ppKSkgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyDQotC40L/QuNC90LMg0LjQvdC00LjQutCw0YLQvtGA0YtcbiAgICAgIG5ld1NvY2tldC5vbigndXNlcl90eXBpbmcnLCAoZGF0YTogeyBjaGF0SWQ6IG51bWJlciwgdXNlcklkOiBudW1iZXIgfSkgPT4ge1xuICAgICAgICBzZXRUeXBpbmdVc2VycyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBhcnIgPSBuZXcgU2V0KHByZXZbZGF0YS5jaGF0SWRdIHx8IFtdKTtcbiAgICAgICAgICBhcnIuYWRkKGRhdGEudXNlcklkKTtcbiAgICAgICAgICByZXR1cm4geyAuLi5wcmV2LCBbZGF0YS5jaGF0SWRdOiBBcnJheS5mcm9tKGFycikgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgbmV3U29ja2V0Lm9uKCd1c2VyX3N0b3BfdHlwaW5nJywgKGRhdGE6IHsgY2hhdElkOiBudW1iZXIsIHVzZXJJZDogbnVtYmVyIH0pID0+IHtcbiAgICAgICAgc2V0VHlwaW5nVXNlcnMocHJldiA9PiB7XG4gICAgICAgICAgY29uc3QgbGlzdCA9IChwcmV2W2RhdGEuY2hhdElkXSB8fCBbXSkuZmlsdGVyKGlkID0+IGlkICE9PSBkYXRhLnVzZXJJZCk7XG4gICAgICAgICAgcmV0dXJuIHsgLi4ucHJldiwgW2RhdGEuY2hhdElkXTogbGlzdCB9O1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWFkIHJlY2VpcHRzXG4gICAgICBuZXdTb2NrZXQub24oJ3JlYWRfcmVjZWlwdCcsIChkYXRhOiB7IGNoYXRJZDogbnVtYmVyLCB1c2VySWQ6IG51bWJlciwgdGltZXN0YW1wOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygn8J+TlyBSZWFkIHJlY2VpcHQnLCBkYXRhKTtcbiAgICAgICAgLy8gaWYgc2VydmVyIG5vdGlmaWVzIHRoaXMgdXNlciB0aGF0IG1lc3NhZ2VzIHdlcmUgcmVhZCwgY2xlYXIgdW5yZWFkIGZvciB0aGF0IGNoYXRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoZGF0YS51c2VySWQgPT09IHVzZXIuaWQpIHtcbiAgICAgICAgICAgIHNldENoYXRzKHByZXYgPT4gcHJldi5tYXAoYyA9PiBjLmlkID09PSBkYXRhLmNoYXRJZCA/IHsgLi4uYywgdW5yZWFkQ291bnQ6IDAgfSA6IGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyDwn4aVINCf0J7Qm9Cj0KfQldCd0JjQlSDQndCe0JLQq9ClINCT0KDQo9Cf0J9cbiAgICAgIG5ld1NvY2tldC5vbignbmV3X2dyb3VwJywgKG5ld0dyb3VwOiBDaGF0KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4aVIFJlY2VpdmVkIG5ldyBncm91cDonLCBuZXdHcm91cCk7XG4gICAgICAgIHNldENoYXRzKHByZXYgPT4ge1xuICAgICAgICAgIC8vINCf0YDQvtCy0LXRgNGP0LXQvCDQvdC10YIg0LvQuCDRg9C20LUg0YLQsNC60L7QuSDQs9GA0YPQv9C/0YtcbiAgICAgICAgICBjb25zdCBleGlzdHMgPSBwcmV2LmZpbmQoY2hhdCA9PiBjaGF0LmlkID09PSBuZXdHcm91cC5pZCk7XG4gICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbmV3R3JvdXAsIC4uLnByZXZdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8g8J+GlSDQn9Ce0JvQo9Cn0JXQndCY0JUg0J3QntCS0KvQpSDQmtCQ0J3QkNCb0J7QklxuICAgICAgbmV3U29ja2V0Lm9uKCduZXdfY2hhbm5lbCcsIChuZXdDaGFubmVsOiBDaGF0KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn4aVIFJlY2VpdmVkIG5ldyBjaGFubmVsOicsIG5ld0NoYW5uZWwpO1xuICAgICAgICBzZXRDaGF0cyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBleGlzdHMgPSBwcmV2LmZpbmQoY2hhdCA9PiBjaGF0LmlkID09PSBuZXdDaGFubmVsLmlkKTtcbiAgICAgICAgICBpZiAoIWV4aXN0cykgcmV0dXJuIFtuZXdDaGFubmVsLCAuLi5wcmV2XTtcbiAgICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8g8J+UhCDQntCR0J3QntCS0JvQldCd0JjQlSDQodCf0JjQodCa0JAg0KfQkNCi0J7QklxuICAgICAgbmV3U29ja2V0Lm9uKCd1cGRhdGVfY2hhdHMnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCfwn5SEIFVwZGF0aW5nIGNoYXRzIGxpc3QnKTtcbiAgICAgICAgbmV3U29ja2V0LmVtaXQoJ2dldF9jaGF0cycsIHVzZXIuaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIPCfk4sg0J/QntCb0KPQp9CV0J3QmNCVINCh0J/QmNCh0JrQkCDQp9CQ0KLQntCSXG4gICAgICBuZXdTb2NrZXQub24oJ2NoYXRzX2xpc3QnLCAoY2hhdHNEYXRhOiBDaGF0W10pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ/Cfk4sgUmVjZWl2ZWQgY2hhdHMgbGlzdDonLCBjaGF0c0RhdGEubGVuZ3RoLCAnY2hhdHMnKTtcbiAgICAgICAgLy8gYXBwbHkgcGVyc2lzdGVkIG11dGVkIGZsYWdzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmF3ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgna3J4X211dGVkX2NoYXRzJykgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IG11dGVkSWRzOiBudW1iZXJbXSA9IHJhdyA/IEpTT04ucGFyc2UocmF3KSA6IFtdO1xuICAgICAgICAgIGNvbnN0IG1hcHBlZCA9IGNoYXRzRGF0YS5tYXAoYyA9PiAoeyAuLi5jLCBtdXRlZDogbXV0ZWRJZHMuaW5jbHVkZXMoYy5pZCkgfSkpO1xuICAgICAgICAgIHNldENoYXRzKG1hcHBlZCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBzZXRDaGF0cyhjaGF0c0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8g8J+SrCDQn9Ce0JvQo9Cn0JXQndCY0JUg0JjQodCi0J7QoNCY0Jgg0KHQntCe0JHQqdCV0J3QmNCZXG4gICAgICBuZXdTb2NrZXQub24oJ21lc3NhZ2VzX2hpc3RvcnknLCAoZGF0YTogeyBjaGF0SWQ6IG51bWJlciwgbWVzc2FnZXM6IE1lc3NhZ2VbXSB9KSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhdCAmJiBkYXRhLmNoYXRJZCA9PT0gY3VycmVudENoYXQuaWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygn8J+SrCBSZWNlaXZlZCBtZXNzYWdlcyBoaXN0b3J5OicsIGRhdGEubWVzc2FnZXMubGVuZ3RoLCAnbWVzc2FnZXMnKTtcbiAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGRhdGEubWVzc2FnZXMubWFwKG5vcm1hbGl6ZU1lc3NhZ2UpO1xuICAgICAgICAgICBzZXRNZXNzYWdlcyhub3JtYWxpemVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgc2V0U29ja2V0KG5ld1NvY2tldCk7XG4gICAgICBsb2FkQ2hhdHMoKTsgLy8g0JTRg9Cx0LvQuNGA0YPQtdC8INC30LDQs9GA0YPQt9C60YMg0YfQtdGA0LXQtyBSRVNUIEFQSVxuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBuZXdTb2NrZXQuZGlzY29ubmVjdCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFt1c2VyLCBjdXJyZW50Q2hhdF0pO1xuXG4gIC8vIFNpbXBsZSBXZWJBdWRpbyBiZWVwIGZvciBub3RpZmljYXRpb24gc291bmQgKHNob3J0IGJlZXApXG4gIGNvbnN0IHBsYXlOb3RpZmljYXRpb25Tb3VuZCA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgQXVkaW9DdHggPSAod2luZG93IGFzIGFueSkuQXVkaW9Db250ZXh0IHx8ICh3aW5kb3cgYXMgYW55KS53ZWJraXRBdWRpb0NvbnRleHQ7XG4gICAgICBpZiAoIUF1ZGlvQ3R4KSByZXR1cm47XG4gICAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9DdHgoKTtcbiAgICAgIGNvbnN0IG8gPSBjdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgY29uc3QgZyA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgICBvLnR5cGUgPSAnc2luZSc7XG4gICAgICBvLmZyZXF1ZW5jeS52YWx1ZSA9IDg4MDsgLy8gQTVcbiAgICAgIGcuZ2Fpbi52YWx1ZSA9IDAuMDAxNTsgLy8gbG93IHZvbHVtZVxuICAgICAgby5jb25uZWN0KGcpO1xuICAgICAgZy5jb25uZWN0KGN0eC5kZXN0aW5hdGlvbik7XG4gICAgICBvLnN0YXJ0KCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgby5zdG9wKCk7XG4gICAgICAgIHRyeSB7IGN0eC5jbG9zZSgpOyB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICB9LCAxMjApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgfTtcblxuICBjb25zdCB0b2dnbGVOb3RpZnkgPSAoZW5hYmxlZD86IGJvb2xlYW4pID0+IHtcbiAgICBjb25zdCBuZXh0ID0gdHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJyA/IGVuYWJsZWQgOiAhbm90aWZ5RW5hYmxlZDtcbiAgICBzZXROb3RpZnlFbmFibGVkKG5leHQpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdrcnhfbm90aWZ5X2VuYWJsZWQnLCBKU09OLnN0cmluZ2lmeShuZXh0KSk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAobmV4dCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnTm90aWZpY2F0aW9uJyBpbiB3aW5kb3cgJiYgTm90aWZpY2F0aW9uLnBlcm1pc3Npb24gPT09ICdkZWZhdWx0Jykge1xuICAgICAgdHJ5IHsgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7IH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdG9nZ2xlU291bmQgPSAoZW5hYmxlZD86IGJvb2xlYW4pID0+IHtcbiAgICBjb25zdCBuZXh0ID0gdHlwZW9mIGVuYWJsZWQgPT09ICdib29sZWFuJyA/IGVuYWJsZWQgOiAhc291bmRFbmFibGVkO1xuICAgIHNldFNvdW5kRW5hYmxlZChuZXh0KTtcbiAgICB0cnkgeyBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdrcnhfc291bmRfZW5hYmxlZCcsIEpTT04uc3RyaW5naWZ5KG5leHQpKTsgfSBjYXRjaCAoZSkge31cbiAgfTtcblxuICBjb25zdCB0b2dnbGVEYXJrTW9kZSA9ICgpID0+IHtcbiAgICBzZXREYXJrTW9kZSgocHJldikgPT4ge1xuICAgICAgY29uc3QgbmV3TW9kZSA9ICFwcmV2O1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3RoZW1lJywgbmV3TW9kZSA/ICdkYXJrJyA6ICdsaWdodCcpO1xuICAgICAgcmV0dXJuIG5ld01vZGU7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQXNrIGZvciBOb3RpZmljYXRpb24gcGVybWlzc2lvbiBvbmNlIG9uIGNsaWVudCAob3B0aW9uYWwpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdOb3RpZmljYXRpb24nIGluIHdpbmRvdykge1xuICAgICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgdHJ5IHsgTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKCk7IH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyDQl9Cw0LPRgNGD0LfQutCwINGH0LDRgtC+0LIg0YfQtdGA0LXQtyBSRVNUIEFQSVxuICBjb25zdCBsb2FkQ2hhdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly9sb2NhbGhvc3Q6NTAwMS9hcGkvY2hhdHM/dXNlcklkPSR7dXNlci5pZH1gKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBjaGF0c0RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNldENoYXRzKGNoYXRzRGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTG9hZGVkIGNoYXRzIHZpYSBSRVNUOicsIGNoYXRzRGF0YS5sZW5ndGgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgbG9hZGluZyBjaGF0czonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vINCX0LDQs9GA0YPQt9C60LAg0YHQvtC+0LHRidC10L3QuNC5XG4gIGNvbnN0IGxvYWRNZXNzYWdlcyA9IGFzeW5jIChjaGF0SWQ6IG51bWJlcikgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjUwMDEvYXBpL21lc3NhZ2VzP2NoYXRJZD0ke2NoYXRJZH0mdXNlcklkPSR7dXNlci5pZH1gKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBtZXNzYWdlc0RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIC8vIEZvciBlYWNoIG1lc3NhZ2UgZmV0Y2ggcmVhY3Rpb25zIChzbWFsbCBvcHRpbWl6YXRpb246IHBhcmFsbGVsIHJlcXVlc3RzKVxuICAgICAgICBjb25zdCBtZXNzYWdlc1dpdGhSZWFjdGlvbnMgPSBhd2FpdCBQcm9taXNlLmFsbChtZXNzYWdlc0RhdGEubWFwKGFzeW5jIChtOiBhbnkpID0+IHtcbiAgICAgICAgICAvLyBub3JtYWxpemUgc2VydmVyIHNoYXBlIGZpcnN0XG4gICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU1lc3NhZ2UobSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBhd2FpdCBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDo1MDAxL2FwaS9tZXNzYWdlcy8ke20uaWR9L3JlYWN0aW9uc2ApO1xuICAgICAgICAgICAgaWYgKHIub2spIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhY3Rpb25zID0gYXdhaXQgci5qc29uKCk7XG4gICAgICAgICAgICAgIHJldHVybiB7IC4uLm5vcm1hbGl6ZWQsIHJlYWN0aW9ucyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7IC4uLm5vcm1hbGl6ZWQsIHJlYWN0aW9uczogW10gfTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzV2l0aFJlYWN0aW9ucyk7XG4gICAgICAgIGNvbnNvbGUubG9nKCfinIUgTG9hZGVkIG1lc3NhZ2VzOicsIG1lc3NhZ2VzRGF0YS5sZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgLy8g0KLQsNC60LbQtSDQt9Cw0L/RgNCw0YjQuNCy0LDQtdC8INGH0LXRgNC10Lcgc29ja2V0INC00LvRjyByZWFsLXRpbWVcbiAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgIHNvY2tldC5lbWl0KCdnZXRfbWVzc2FnZXMnLCB7IGNoYXRJZCwgdXNlcklkOiB1c2VyLmlkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBsb2FkaW5nIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdG9nZ2xlTXV0ZSA9IChjaGF0SWQ6IG51bWJlcikgPT4ge1xuICAgIHNldENoYXRzKHByZXYgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IHByZXYubWFwKGMgPT4gYy5pZCA9PT0gY2hhdElkID8geyAuLi5jLCBtdXRlZDogIWMubXV0ZWQgfSA6IGMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbXV0ZWRJZHMgPSB1cGRhdGVkLmZpbHRlcihjID0+IGMubXV0ZWQpLm1hcChjID0+IGMuaWQpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdrcnhfbXV0ZWRfY2hhdHMnLCBKU09OLnN0cmluZ2lmeShtdXRlZElkcykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZ25vcmVcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFwcGx5IHRoZW1lIG9uIGluaXRpYWxpemF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QudG9nZ2xlKCdkYXJrJywgZGFya01vZGUpO1xuICB9LCBbZGFya01vZGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxBcHBDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IFxuICAgICAgdXNlciwgXG4gICAgICBzZXRVc2VyLCBcbiAgICAgIHNvY2tldCwgXG4gICAgICBkYXJrTW9kZSwgXG4gICAgICB0b2dnbGVEYXJrTW9kZSxcbiAgICAgIGNoYXRzLFxuICAgICAgc2V0Q2hhdHMsXG4gICAgICBjdXJyZW50Q2hhdCxcbiAgICAgIHNldEN1cnJlbnRDaGF0LFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzZXRNZXNzYWdlcyxcbiAgICAgIHRvZ2dsZU11dGUsXG4gICAgICBub3RpZnlFbmFibGVkLFxuICAgICAgdG9nZ2xlTm90aWZ5LFxuICAgICAgc291bmRFbmFibGVkLFxuICAgICAgdG9nZ2xlU291bmQsXG4gICAgICB0eXBpbmdVc2VycyxcbiAgICAgIGxvYWRDaGF0cyxcbiAgICAgIGxvYWRNZXNzYWdlcyxcbiAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgY2hlY2tCbG9ja1N0YXR1cyxcbiAgICAgIGJsb2NrZWRVc2VycyxcbiAgICAgIHJlZnJlc2hCbG9ja2VkVXNlcnNcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0FwcENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgdXNlQXBwID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXNlQXBwIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXBwUHJvdmlkZXInKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07Il0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImlvIiwiQXBwQ29udGV4dCIsInVuZGVmaW5lZCIsIkFwcFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwiX3NldFVzZXIiLCJibG9ja2VkVXNlcnMiLCJzZXRCbG9ja2VkVXNlcnMiLCJTZXQiLCJyZWZyZXNoQmxvY2tlZFVzZXJzIiwicmVzcG9uc2UiLCJmZXRjaCIsImlkIiwib2siLCJFcnJvciIsImRhdGEiLCJqc29uIiwiZXJyIiwiY29uc29sZSIsImVycm9yIiwiY2hlY2tCbG9ja1N0YXR1cyIsInVzZXJJZCIsImlzQmxvY2tlZCIsInNldFVzZXIiLCJ1IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZW1vdmVJdGVtIiwiZSIsIndhcm4iLCJyYXciLCJnZXRJdGVtIiwicGFyc2VkIiwicGFyc2UiLCJzb2NrZXQiLCJzZXRTb2NrZXQiLCJkYXJrTW9kZSIsInNldERhcmtNb2RlIiwiY2hhdHMiLCJzZXRDaGF0cyIsImN1cnJlbnRDaGF0Iiwic2V0Q3VycmVudENoYXQiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwidHlwaW5nVXNlcnMiLCJzZXRUeXBpbmdVc2VycyIsIm5vdGlmeUVuYWJsZWQiLCJzZXROb3RpZnlFbmFibGVkIiwic291bmRFbmFibGVkIiwic2V0U291bmRFbmFibGVkIiwic2VuZE1lc3NhZ2UiLCJjb250ZW50IiwiY2hhdElkIiwibWVzc2FnZVR5cGUiLCJpc0NvbW1lbnQiLCJtZXNzYWdlRGF0YSIsInNlbmRlcklkIiwidHJpbSIsImxvZyIsImVtaXQiLCJvcHRpbWlzdGljTWVzc2FnZSIsIkRhdGUiLCJub3ciLCJpc1JlYWQiLCJ0aW1lc3RhbXAiLCJ0b0lTT1N0cmluZyIsInVzZXJuYW1lIiwiZGlzcGxheU5hbWUiLCJhdmF0YXJVcmwiLCJwcmV2Iiwibm9ybWFsaXplTWVzc2FnZSIsIm0iLCJOdW1iZXIiLCJjaGF0X2lkIiwic2VuZGVyX2lkIiwic3RhcnRzV2l0aCIsIm1lc3NhZ2VfdHlwZSIsImlzX3JlYWQiLCJjcmVhdGVkX2F0IiwidXNlck5hbWUiLCJkaXNwbGF5X25hbWUiLCJhIiwiYXZhdGFyX3VybCIsInJlYWN0aW9ucyIsIm5ld1NvY2tldCIsInRyYW5zcG9ydHMiLCJyZWNvbm5lY3Rpb24iLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsIkluZmluaXR5IiwicmVjb25uZWN0aW9uRGVsYXkiLCJyZWNvbm5lY3Rpb25EZWxheU1heCIsImF1dG9Db25uZWN0Iiwib24iLCJyYXdNc2ciLCJtZXNzYWdlIiwiZmlsdGVyZWQiLCJmaWx0ZXIiLCJ0UHJldiIsImdldFRpbWUiLCJ0TXNnIiwiTWF0aCIsImFicyIsIm1hcCIsImMiLCJ1bnJlYWRDb3VudCIsImxhc3RNZXNzYWdlIiwibGFzdE1lc3NhZ2VUaW1lIiwibGFzdE1lc3NhZ2VTZW5kZXIiLCJjaGF0IiwiZmluZCIsImNoIiwiaXNNdXRlZCIsIm11dGVkIiwid2luZG93IiwiTm90aWZpY2F0aW9uIiwicGVybWlzc2lvbiIsInRpdGxlIiwidHlwZSIsIm90aGVyVXNlciIsIm5hbWUiLCJib2R5Iiwic2xpY2UiLCJpY29uIiwicGxheU5vdGlmaWNhdGlvblNvdW5kIiwibWVzc2FnZUlkIiwiZXhpc3RpbmciLCJlbW9qaSIsImNyZWF0ZWRBdCIsInIiLCJhcnIiLCJhZGQiLCJBcnJheSIsImZyb20iLCJsaXN0IiwibmV3R3JvdXAiLCJleGlzdHMiLCJuZXdDaGFubmVsIiwiY2hhdHNEYXRhIiwibGVuZ3RoIiwibXV0ZWRJZHMiLCJtYXBwZWQiLCJpbmNsdWRlcyIsIm5vcm1hbGl6ZWQiLCJsb2FkQ2hhdHMiLCJkaXNjb25uZWN0IiwiQXVkaW9DdHgiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJjdHgiLCJvIiwiY3JlYXRlT3NjaWxsYXRvciIsImciLCJjcmVhdGVHYWluIiwiZnJlcXVlbmN5IiwidmFsdWUiLCJnYWluIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwic3RhcnQiLCJzZXRUaW1lb3V0Iiwic3RvcCIsImNsb3NlIiwidG9nZ2xlTm90aWZ5IiwiZW5hYmxlZCIsIm5leHQiLCJyZXF1ZXN0UGVybWlzc2lvbiIsInRvZ2dsZVNvdW5kIiwidG9nZ2xlRGFya01vZGUiLCJuZXdNb2RlIiwibG9hZE1lc3NhZ2VzIiwibWVzc2FnZXNEYXRhIiwibWVzc2FnZXNXaXRoUmVhY3Rpb25zIiwiUHJvbWlzZSIsImFsbCIsInRvZ2dsZU11dGUiLCJ1cGRhdGVkIiwiZG9jdW1lbnQiLCJjbGFzc0xpc3QiLCJ0b2dnbGUiLCJQcm92aWRlciIsInVzZUFwcCIsImNvbnRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/contexts/AppContext.tsx\n"));

/***/ })

});